{"version":3,"sources":["core/MongoPortable.ts"],"names":[],"mappings":"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","file":"MongoPortable.js","sourcesContent":["/**\n * @file MongoPortable.js - based on Monglo ({@link https://github.com/Monglo}) by Christian Sullivan <cs@euforic.co> | Copyright (c) 2012\n * @version 1.0.0\n * \n * @author Eduardo Astolfi <eastolfi91@gmail.com>\n * @copyright 2016 Eduardo Astolfi <eastolfi91@gmail.com>\n * @license MIT Licensed\n */\nimport * as _               from \"lodash\";\nimport { JSWLogger }        from \"jsw-logger\";\n\nimport { Options }          from \"./Options\";\n\nimport { EventEmitter }     from \"../emitter\";\nimport { Collection }       from \"../collection\";\nimport { ObjectId }         from \"../document\";\nimport { Utils }            from \"../utils\";\n\n// if (!Object.prototype.renameProperty) {\n//     /**\n//      * Renames an object property.\n//      * \n//      * @method Object#renameProperty\n//      * \n//      * @param {String} oldName - The name of the property to rename\n//      * @param {String} newName - The new name of the property\n//      * \n//      * @returns {this} The called object\n//      */\n//     Object.defineProperty(\n//         Object.prototype, \n//         \"renameProperty\",\n//         {\n//             writable : false, // Cannot alter this property\n//             enumerable : false, // Will not show up in a for-in loop.\n//             configurable : false, // Cannot be deleted via the delete operator\n//             value : function (oldName, newName) {\n//                 // Do nothing if some name is missing or is not an string\n//                 if (!_.isString(oldName) || !_.isString(newName)) {\n//                     return this;\n//                 }\n                \n//                 // Do nothing if the names are the same\n//                 if (oldName == newName) {\n//                     return this;\n//                 }\n                \n//                 // Check for the old property name to \n//                 // avoid a ReferenceError in strict mode.\n//                 if (this.hasOwnProperty(oldName)) {\n//                     this[newName] = this[oldName];\n//                     delete this[oldName];\n//                 }\n                \n//                 return this;\n//             }\n//         }\n//     );\n// }\n\nclass ConnectionHelper {\n    private _pool: Array<{name: string, id: any}>;\n    \n    constructor() {\n        this._pool = [];\n    }\n    \n    addConnection(name: string, id:any) {\n        if (!this.hasConnection(name)) {\n            this._pool.push({ name, id });\n        }\n    }\n    \n    dropConnection(name: string) {\n        for (let i = 0; i < this._pool.length; i++) {\n            if (this._pool[i].name === name) {\n                this._pool.splice(i, 1);\n                \n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    hasConnection(name: string) {\n        for (let conn of this._pool) {\n            if (conn.name === name) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n    \n    /**\n     * Validates the database name\n     * \n     * @method MongoPortable#_validateDatabaseName\n     * @private\n     * \n     * @param {String} databaseName - The name of the database to validate\n     * \n     * @return {Boolean} \"true\" if the name is valid\n     */\n    validateDatabaseName(name: string) {\n        let logger = JSWLogger.instance;\n        \n        if (!_.isString(name)) logger.throw(\"database name must be a string\");\n    \n        if (name.length === 0) logger.throw(\"database name cannot be the empty string\");\n    \n        let invalidChars = [\" \", \".\", \"$\", \"/\", \"\\\\\"];\n        for(let i = 0; i < invalidChars.length; i++) {\n            if(name.indexOf(invalidChars[i]) != -1) {\n                logger.throw(`database names cannot contain the character \"${invalidChars[i]}\"`);\n            }\n        }\n        \n        return true;\n    }\n}\n\n/**\n * MongoPortable\n * \n * @module MongoPortable\n * @since 0.0.1\n * \n * @classdesc Portable database with persistence and MongoDB-like API\n * \n * @param {string} databaseName - Name of the database.\n */\nclass MongoPortable extends EventEmitter {\n    protected logger: JSWLogger;\n    \n    private _collections: {};\n    private _stores: Array<Object|Function>;\n    private _databaseName: string;\n    \n    private static _connHelper: ConnectionHelper = new ConnectionHelper();\n    // static version = \"0.0.1\";\n    \n    pkFactory;\n    \n    constructor(databaseName: string, options: Options) {\n        super(options || new Options());\n        \n        this.logger = JSWLogger.instance;\n        \n        this._collections = {};\n        this._stores = [];\n        \n        // Check ddbb name format\n        MongoPortable._connHelper.validateDatabaseName(databaseName);\n    \n        // FIXME: Temp patch until I figure out how far I want to take the implementation;\n        if (MongoPortable._connHelper.hasConnection(databaseName)) {\n            this.logger.throw(`The database name \"${databaseName}\" is already in use`);\n        }\n    \n        this._databaseName = databaseName;\n    \n        MongoPortable._connHelper.addConnection(databaseName, new ObjectId());\n    }\n    \n    emit(name: string, args: Object) {\n        super.emit(name, args, this._stores);\n    }\n    \n    /**\n     * Middleware functions\n     * \n     * @param  {String} name - Name of the middleware:\n     *      <ul>\n     *          <li>\"store\": Add a custom store</li>\n     *      </ul>\n     * @param  {Object|Function} fn - Function to implement the middleware\n     */\n    use(name, obj) {\n        switch(name) {\n            case \"store\":\n                this._stores.push(obj);\n                break;\n        }\n    }\n    \n    /**\n     * Adds a custom stores for remote and local persistence\n     *\n     * @param {Object|Function} store - The custom store\n     * \n     * @returns {MongoPortable} this - The current Instance\n     */\n    addStore(store) {\n        if (_.isNil(store)) this.logger.throw(\"missing \\\"store\\\" parameter\");\n        \n        if (_.isFunction(store)) {\n            this._stores.push(new store());\n        } else if (_.isObject(store)) {\n            this._stores.push(store);\n        } else {\n            this.logger.throw(\"\\\"store\\\" must be a function or object\");\n        }\n        \n        return this;\n    }\n    \n    /**\n     * Returns a cursor to all the collection information.\n     * \n     * @param {String} [collectionName=null] - the collection name we wish to retrieve the information from.\n     * @param {Function} [callback=null] - Callback function to be called at the end with the results\n     * \n     * @returns {Array}\n     *\n     * @todo Implement\n     */\n    collectionsInfo(collectionName, callback) {\n        this.logger.throw(\"Not implemented yet\");\n    }\n    \n    /**\n     * Alias for {@link MongoPortable#collections}\n     * \n     * @method MongoPortable#fetchCollections\n     */\n    fetchCollections(options, callback) {\n        return this.collections(options, callback);\n    }\n    \n    /**\n     * Get the list of all collection for the specified db\n     *\n     * @method MongoPortable#collections\n     * \n     * @param {Object} [options] - Additional options\n     * \n     * @param {Boolean} [options.namesOnly=false] - Return only the collections names\n     * @param {String|Array} [options.collectionName=null] - The collection name we wish to filter by\n     * \n     * @param {Function} [callback=null] - Callback function to be called at the end with the results\n     *\n     * @return {Array} \n     */\n    collections(options, callback) {\n        if (_.isNil(callback) && _.isFunction(options)) {\n            callback = options;\n        }\n        \n        if (_.isNil(options)) options = {};\n        \n        var self = this;\n        \n        var collectionList = [];\n        for (var name in self._collections) {\n            // Only add the requested collections //TODO Add array type\n            if (options.collectionName) {\n                if (name.toLowerCase() === options.collectionName.toLowerCase()) {\n                    if (options.namesOnly) {\n                        collectionList.push(name);\n                    } else {\n                        collectionList.push(self._collections[name]);\n                    }\n                }\n            } else {\n                if (options.namesOnly) {\n                    collectionList.push(name);\n                } else {\n                    collectionList.push(self._collections[name]);\n                }\n            }\n        }\n    \n        if (callback) callback(collectionList);\n        \n        return collectionList;\n    }\n    \n    /**\n     * Get the list of all collection names for the specified db, \n     *  by calling MongoPortable#collections with [options.namesOnly = true]\n     *\n     * @method MongoPortable#collectionNames\n     * \n     * @param {Object} [options] - Additional options.\n     * \n     * @param {String|Array} [options.collectionName=null] - The collection name we wish to filter by.\n     * \n     * @param {Function} [callback=null] - Callback function to be called at the end with the results\n     *\n     * @return {Array}\n     * \n     * {@link MongoPortable#collections}\n     */\n    collectionNames(options, callback) {\n        if (_.isNil(callback) && _.isFunction(options)) {\n            callback = options;\n        }\n        \n        if (_.isNil(options)) options = {};\n        \n        if (!options.namesOnly) options.namesOnly = true;\n        \n        return this.collections(options, callback);\n    }\n    \n    /**\n     * Creates a collection on a server pre-allocating space, need to create f.ex capped collections.\n     * \n     * @method MongoPortable#collection\n     * \n     * @param {String} collectionName - the collection name we wish to access.\n     * @param {Object} [options] - returns option results.\n     * \n     * @param {Boolean|Object} [options.safe=false] Executes with a getLastError command returning the results of the command on MongoMonglo:\n     *      <ul>\n     *          <li>true</li>\n     *          <li>false</li>\n     *          <li>{ w: {Number}, wtimeout: {Number}}</li>\n     *          <li>{ fsync: true }</li>\n     *      </ul>\n     * @param {Boolean} [options.serializeFunctions=false] - Serialize functions on the document.\n     * @param {Boolean} [options.raw=false] - Perform all operations using raw bson objects.\n     * @param {Object} [options.pkFactory=null] - Object overriding the basic ObjectId primary key generation.\n     * @param {Boolean} [options.capped=false] - Create a capped collection.\n     * @param {Number} [options.size=4096] - The size of the capped collection in bytes.\n     * @param {Number} [options.max=500] - The maximum number of documents in the capped collection.\n     * @param {Boolean} [options.autoIndexId=false] - Create an index on the _id field of the document, not created automatically on capped collections.\n     * @param {String} [options.readPreference=ReadPreference.PRIMARY] - Te prefered read preference:\n     *      <ul>\n     *          <li>ReadPreference.PRIMARY</li>\n     *          <li>ReadPreference.PRIMARY_PREFERRED</li>\n     *          <li>ReadPreference.SECONDARY</li>\n     *          <li>ReadPreference.SECONDARY_PREFERRED</li>\n     *          <li>ReadPreference.NEAREST</li>\n     *      </ul>\n     * \n     * @param {Function} [callback=null] - Callback function to be called at the end with the results\n     * \n     * @fires {@link MongoStore#createCollection}\n     * \n     * @returns {Collection}\n     */\n    collection(collectionName, options, callback) {\n        var existing = false;\n        // var collection;\n        // var collectionFullName =  self.databaseName + \".\" + collectionName;\n    \n        if (_.isFunction(options)){\n            callback = options;\n            options = {};\n        } else {\n            options = options || {};\n        }\n        \n        // Collection already in memory, lets create it\n        if (this._collections[collectionName]) {\n            /**\n             * \"createCollection\" event.\n             *\n             * @event MongoPortable~createCollection\n             * \n             * @property {Object} connection - Information about the current database connection\n             * @property {Object} collection - Information about the collection created\n             */\n            this.emit(\n                \"createCollection\",\n                {\n                    connection: this,\n                    collection: this._collections[collectionName]\n                }\n            );\n    \n            existing = true;\n        } else {\n            this._collections[collectionName] = new Collection(this, collectionName/*, this.pkFactory*//*, options*/);\n            /**\n             * \"createCollection\" event.\n             *\n             * @event MongoPortable~createCollection\n             * \n             * @property {Object} connection - Information about the current database connection\n             * @property {Object} collection - Information about the collection created\n             */\n            this.emit(\n                \"createCollection\",\n                {\n                    connection: this,\n                    collection: this._collections[collectionName]\n                }\n            );\n        }\n        \n        if (!existing) {\n            // Letting access the collection by <MongoPortable instance>.<COL_NAME>\n            Object.defineProperty(MongoPortable.prototype, collectionName, {\n                enumerable : true,\n                configurable : true,\n                writable: false,\n                value: this._collections[collectionName]\n            });\n        }\n        \n        // return self._collections[collectionName];\n        if (callback) callback(this._collections[collectionName]);\n    \n        return this._collections[collectionName];\n    }\n    \n    /**\n     * Alias for {@link MongoPortable#collection}\n     * \n     * @method MongoPortable#createCollection\n     */\n    createCollection = this.collection;\n    \n    /**\n     * Drop a collection from the database, removing it permanently. New accesses will create a new collection.\n     * \n     * @method MongoPortable#dropCollection\n     *\n     * @param {String} collectionName - The name of the collection we wish to drop.\n     * @param {Function} [callback=null] - Callback function to be called at the end with the results\n     * \n     * @returns {Boolean} \"true\" if dropped successfully\n     */\n    dropCollection(collectionName, callback) {\n        if (this._collections[collectionName]) {\n            // Drop the collection\n            this.emit(\n                \"dropCollection\",\n                {\n                    conn: this,\n                    collection: this._collections[collectionName]\n                }\n            );\n            \n            delete this._collections[collectionName];\n            \n            if (callback && _.isFunction(callback)) callback();\n            \n            return true;\n        } else {\n            var msg = \"No collection found\";\n            \n            this.logger.error(msg);\n            \n            if (callback && _.isFunction(callback)) callback(new Error(msg));\n            \n            return false;\n        }\n    }\n    \n    /**\n     * Rename a collection.\n     *\n     * @method MongoPortable#renameCollection\n     * \n     * @param {String} fromCollection - The name of the current collection we wish to rename.\n     * @param {String} toCollection - The new name of the collection.\n     * @param {Function} [callback=null] - Callback function to be called at the end with the results\n     * \n     * @returns {Boolean|Collection} The collection if renamed successfully or false if not\n     */\n    renameCollection(fromCollection, toCollection, callback) {\n        if (_.isString(fromCollection) && _.isString(toCollection) && fromCollection !== toCollection) {\n            // Execute the command, return the new renamed collection if successful\n            Collection.checkCollectionName(toCollection);\n            \n            if (this._collections[fromCollection]) {\n                this.emit(\n                    \"renameCollection\",\n                    {\n                        conn: this,\n                        from: fromCollection,\n                        to: toCollection\n                    }\n                );\n                \n                var renamed = this._collections[fromCollection].rename(toCollection);\n                Utils.renameObjectProperty(this._collections, fromCollection, toCollection);\n                // this._collections.renameProperty(fromCollection, toCollection);\n                // this.renameProperty(fromCollection, toCollection);\n                Utils.renameObjectProperty(this, fromCollection, toCollection);\n                \n                if (callback && _.isFunction(callback)) callback(null, renamed);\n                \n                return renamed;\n            } else {\n                let msg = \"No collection found\";\n                \n                this.logger.error(msg);\n                \n                if (callback && _.isFunction(callback)) callback(new Error(msg), null);\n                \n                return false;\n            }\n        } else {\n            let msg = \"The params are invalid\";\n            \n            this.logger.error(msg);\n            \n            if (callback && _.isFunction(callback)) callback(new Error(msg), null);\n            \n            return false;\n        }\n    }\n    \n    /**\n     * Creates an index on the collection.\n     * \n     * @method MongoPortable#createIndex\n     *\n     * @param {String} collectionName - Name of the collection to create the index on.\n     * @param {Object} fieldOrSpec - FieldOrSpec that defines the index.\n     * @param {Object} [options] - Additional options during update.\n     * \n     * @param {Boolean|Object} [options.safe=false] Executes with a getLastError command returning the results of the command on MongoMonglo:\n     *      <ul>\n     *          <li>true</li>\n     *          <li>false</li>\n     *          <li>{ w: {Number}, wtimeout: {Number}}</li>\n     *          <li>{ fsync: true }</li>\n     *      </ul> \n     * @param {Boolean} [options.unique=false] - Creates an unique index\n     * @param {Boolean} [options.sparse=false] - Creates a sparse index\n     * @param {Boolean} [options.background=false] - Creates the index in the background, yielding whenever possible\n     * @param {Boolean} [options.dropDups=false] - A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n     * @param {Number} [options.min=null] - For geospatial indexes set the lower bound for the co-ordinates\n     * @param {Number} [options.max=null] - For geospatial indexes set the high bound for the co-ordinates\n     * @param {Number} [options.v=null] - Specify the format version of the indexes\n     * @param {Number} [options.expireAfterSeconds=null] - Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n     * @param {String} [options.name=null] - Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n     * \n     * @param {Function} [callback=null] - Callback function to be called at the end with the results\n     * \n     * @todo Implement\n     */\n    createIndex(collectionName, fieldOrSpec, options, callback) {\n        this.logger.throw(\"Not implemented yet!\");\n    }\n    \n    /**\n     * Ensures that an index exists, if it does not it creates it\n     * \n     * @method MongoPortable#ensureIndex\n     *\n     * @param {String} collectionName - Name of the collection to create the index on.\n     * @param {Object} fieldOrSpec - FieldOrSpec that defines the index.\n     * @param {Object} [options] - Additional options during update.\n     * \n     * @param {Boolean|Object} [options.safe=false] - Executes with a getLastError command returning the results of the command on MongoMonglo:\n     *      <ul>\n     *          <li>true</li>\n     *          <li>false</li>\n     *          <li>{ w: {Number}, wtimeout: {Number}}</li>\n     *          <li>{ fsync: true }</li>\n     *      </ul>\n     * @param {Boolean} [options.unique=false] - Creates an unique index\n     * @param {Boolean} [options.sparse=false] - Creates a sparse index\n     * @param {Boolean} [options.background=false] - Creates the index in the background, yielding whenever possible\n     * @param {Boolean} [options.dropDups=false] - A unique index cannot be created on a key that has pre-existing duplicate values. If you would like to create the index anyway, keeping the first document the database indexes and deleting all subsequent documents that have duplicate value\n     * @param {Number} [options.min] - For geospatial indexes set the lower bound for the co-ordinates\n     * @param {Number} [options.max] - For geospatial indexes set the high bound for the co-ordinates\n     * @param {Number} [options.v] - Specify the format version of the indexes\n     * @param {Number} [options.expireAfterSeconds] - Allows you to expire data on indexes applied to a data (MongoDB 2.2 or higher)\n     * @param {String} [options.name] - Override the autogenerated index name (useful if the resulting name is larger than 128 bytes)\n     * \n     * @param {Function} [callback=null] - Callback function to be called at the end with the results\n     * \n     * @todo Implement\n     */\n    ensureIndex(collectionName, fieldOrSpec, options, callback) {\n        this.logger.throw(\"Not implemented yet!\");\n    }\n    \n    /**\n     * Drop an index on a collection.\n     * \n     * @method MongoPortable#dropIndex\n     *\n     * @param {String} collectionName - The name of the collection where the command will drop an index.\n     * @param {String} indexName - Name of the index to drop.\n     * @param {Function} [callback=null] - Callback function to be called at the end with the results\n     * \n     * @todo Implement\n     */\n    dropIndex(collectionName, indexName, callback) {\n        this.logger.throw(\"Not implemented yet!\");\n    }\n    \n    /**\n     * Reindex all indexes on the collection\n     * Warning: \"reIndex\" is a blocking operation (indexes are rebuilt in the foreground) and will be slow for large collections.\n     * \n     * @method MongoPortable#reIndex\n     *\n     * @param {String} collectionName - The name of the collection to reindex\n     * @param {Function} [callback=null] - Callback function to be called at the end with the results\n     * \n     * @todo Implement\n     **/\n    reIndex(collectionName, callback) {\n        this.logger.throw(\"Not implemented yet!\");\n    }\n    \n    /**\n     * Retrieves this collections index info.\n     * \n     * @method MongoPortable#indexInformation\n     *\n     * @param {String} collectionName - The name of the collection.\n     * @param {Object} [options] Additional options during update.\n     * \n     * @param {Boolean} [full=false] - Returns the full raw index information.\n     * @param {String} [readPreference] - The preferred read preference ((Server.PRIMARY, Server.PRIMARY_PREFERRED, Server.SECONDARY, Server.SECONDARY_PREFERRED, Server.NEAREST).\n     * \n     * @param {Function} [callback=null] - Callback function to be called at the end with the results\n     * \n     * @todo Implement\n     */\n    indexInformation(collectionName, options, callback) {\n        this.logger.throw(\"Not implemented yet!\");\n    }\n    \n    /**\n     * Drop the whole database.\n     * \n     * @method MongoPortable#dropDatabase\n     *\n     * @param {Function} [callback=null] - Callback function to be called at the end with the results\n     * \n     * @return {Boolean} \"true\" if dropped successfully\n     */\n    dropDatabase(callback) {\n        if (MongoPortable._connHelper.hasConnection(this._databaseName)) {\n            this.emit(\n                \"dropDatabase\",\n                {\n                    conn: this\n                }\n            );\n            \n            MongoPortable._connHelper.dropConnection(this._databaseName);\n            \n            this._collections = [];\n            this._stores = [];\n            \n            if (callback && _.isFunction(callback)) callback(null, true);\n            \n            return true;\n        } else {\n            let msg = \"That database no longer exists\";\n            \n            this.logger.error(msg);\n            \n            if (callback && _.isFunction(callback)) callback(new Error(msg), false);\n            \n            return false;\n        }\n    }\n    \n    /**\n     * Dereference a dbref, against a db\n     *\n     * @param {DBRef} dbRef db reference object we wish to resolve.\n     * @param {Function} [callback=null] Callback function to be called at the end with the results\n     * \n     * @todo Implement\n     * \n     * @ignore\n     */\n    dereference(dbRef, callback) {\n        // TODO\n        // var db = this;\n    \n        // // If we have a db reference then let\"s get the db first\n        // if (dbRef.db !== null) db = this.db(dbRef.db);\n    \n        // // Fetch the collection and find the reference\n        // var collection = Monglo.collection(dbRef.namespace);\n    \n        // collection.findOne({\"_id\":dbRef.oid}, function(err, result) {\n        //     callback(err, result);\n        // });\n    }\n}\n\nexport { MongoPortable };"]}